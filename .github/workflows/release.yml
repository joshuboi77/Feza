name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Triggers on semantic version tags like v1.2.3
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag (e.g., v1.2.3)"
        required: true
        type: string
      name:
        description: "Tool name"
        required: true
        type: string
      targets:
        description: "Comma-separated targets (default: macos-arm64,macos-amd64,linux-amd64)"
        required: false
        type: string
        default: "macos-arm64,macos-amd64,linux-amd64"

permissions:
  contents: write  # Required to create releases and upload assets

jobs:
  plan:
    runs-on: ubuntu-latest
    outputs:
      TAG: ${{ steps.vars.outputs.TAG }}
      NAME: ${{ steps.vars.outputs.NAME }}
      TARGETS: ${{ steps.vars.outputs.TARGETS }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Feza
        run: |
          python -m pip install --upgrade pip
          pip install -e .

      - name: Set variables
        id: vars
        run: |
          echo "TAG=${{ inputs.tag || github.ref_name }}" >> $GITHUB_OUTPUT
          echo "NAME=${{ inputs.name || 'feza' }}" >> $GITHUB_OUTPUT
          echo "TARGETS=${{ inputs.targets || 'macos-arm64,macos-amd64,linux-amd64' }}" >> $GITHUB_OUTPUT

      - name: Plan release
        run: |
          feza plan "${{ steps.vars.outputs.TAG }}" --name "${{ steps.vars.outputs.NAME }}" --targets "${{ steps.vars.outputs.TARGETS }}"
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}

      - name: Upload manifest
        uses: actions/upload-artifact@v4
        with:
          name: manifest
          path: dist/feza_manifest.json

      - name: Upload Python script (if generated)
        uses: actions/upload-artifact@v4
        continue-on-error: true
        with:
          name: python-script
          path: create_python_binaries.sh

  build:
    needs: plan
    runs-on: ${{ matrix.os }}
    outputs:
      TAG: ${{ needs.plan.outputs.TAG }}
      NAME: ${{ needs.plan.outputs.NAME }}
      TARGETS: ${{ needs.plan.outputs.TARGETS }}
    strategy:
      matrix:
        include:
          - os: macos-14
            target: macos-arm64
          - os: macos-14
            target: macos-amd64
          - os: ubuntu-latest
            target: linux-amd64
          - os: windows-latest
            target: windows-amd64
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Feza
        run: |
          python -m pip install --upgrade pip
          pip install -e .

      - name: Download manifest
        uses: actions/download-artifact@v4
        with:
          name: manifest
          path: dist/

      - name: Download Python script (if exists)
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: python-script
          path: .

      - name: Build artifacts
        shell: bash
        run: |
          # Find create_python_binaries.sh (artifact download might put it in a subdirectory)
          SCRIPT_PATH=$(find . -name "create_python_binaries.sh" -type f 2>/dev/null | head -1)
          
          if [ -n "$SCRIPT_PATH" ] && [ -f "$SCRIPT_PATH" ]; then
            echo "Python project detected - found script at: $SCRIPT_PATH"
            echo "Running create_python_binaries.sh to create wrapper binaries..."
            chmod +x "$SCRIPT_PATH"
            "$SCRIPT_PATH"
            echo "Verifying binaries were created:"
            ls -la build/*/ || echo "No build directories found"
          else
            echo "Warning: create_python_binaries.sh not found"
            echo "TODO: Build your binary for ${{ matrix.target }}"
            echo "Binary should be placed at: build/${{ matrix.target }}/${{ needs.plan.outputs.NAME }}"
            mkdir -p build/${{ matrix.target }}
            touch build/${{ matrix.target }}/${{ needs.plan.outputs.NAME }}
          fi

      - name: Package and compute checksums
        shell: bash
        run: |
          feza build ${{ needs.plan.outputs.TAG }} --name ${{ needs.plan.outputs.NAME }} \
            --artifacts-dir build/ \
            --dist dist/ \
            --repo ${{ github.repository }} \
            --target ${{ matrix.target }}

      - name: Upload package
        uses: actions/upload-artifact@v4
        with:
          name: package-${{ matrix.target }}
          path: dist/*.tar.gz
          if-no-files-found: error

      - name: Upload updated manifest
        uses: actions/upload-artifact@v4
        with:
          name: manifest-updated-${{ matrix.target }}
          path: dist/feza_manifest.json

  merge-manifest:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download all manifests
        uses: actions/download-artifact@v4
        with:
          pattern: manifest-updated-*
          path: manifests/

      - name: Merge manifest
        run: |
          python -c "
          import json
          import glob
          import os
          import sys
          
          manifests = [json.load(open(f)) for f in glob.glob('manifests/**/feza_manifest.json', recursive=True)]
          if not manifests:
              print('::error::No manifests found to merge')
              sys.exit(1)
          
          merged = manifests[0]
          expected_targets = {a['target'] for a in merged['assets']}
          
          for m in manifests[1:]:
              for asset in m['assets']:
                  existing = next((a for a in merged['assets'] if a['target'] == asset['target']), None)
                  if existing:
                      # Preserve non-empty values (prefer complete data over empty)
                      for key in ['sha256', 'url']:
                          if asset.get(key) and (not existing.get(key) or not existing.get(key).strip()):
                              existing[key] = asset[key]
                          elif not existing.get(key):
                              existing[key] = asset.get(key, '')
                  else:
                      print('::warning::Unexpected target in manifest: ' + asset['target'])
          
          # Validate all targets have sha256 and url
          missing = []
          for asset in merged['assets']:
              if not asset.get('sha256') or not asset.get('sha256').strip():
                  missing.append(asset['target'] + ' (missing sha256)')
              if not asset.get('url') or not asset.get('url').strip():
                  missing.append(asset['target'] + ' (missing url)')
          
          if missing:
              print('::error::Missing data in merged manifest: ' + ', '.join(missing))
              sys.exit(1)
          
          os.makedirs('dist', exist_ok=True)
          json.dump(merged, open('dist/feza_manifest.json', 'w'), indent=2)
          print('Merged manifest with ' + str(len(merged['assets'])) + ' assets')
          "

      - name: Upload final manifest
        uses: actions/upload-artifact@v4
        with:
          name: manifest-final
          path: dist/feza_manifest.json

  github:
    needs: [plan, merge-manifest]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Feza
        run: |
          python -m pip install --upgrade pip
          pip install -e .

      - name: Install GitHub CLI
        run: |
          if ! command -v gh &> /dev/null; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh -y
          fi

      - name: Authenticate GitHub CLI
        run: echo "GitHub CLI will use GH_TOKEN environment variable"
        env:
          GH_TOKEN: ${{ secrets.TAP_PAT || secrets.GITHUB_TOKEN }}

      - name: Download manifest and packages
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: manifest-final
          path: dist/

      - name: Download all packages
        uses: actions/download-artifact@v4
        with:
          pattern: package-*
          path: dist/
          merge-multiple: true

      - name: Create/update GitHub release
        run: |
          feza github ${{ needs.plan.outputs.TAG }} --name ${{ needs.plan.outputs.NAME }} \
            --repo ${{ github.repository }} \
            --dist dist/
        env:
          GH_TOKEN: ${{ secrets.TAP_PAT || secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}

  tap:
    needs: [plan, github]
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
        with:
          path: main-repo

      - name: Determine tap repository
        id: tap
        run: |
          # Use explicit TAP_REPO secret if set, otherwise auto-detect: {org}/homebrew-{tool_name}
          ORG=$(echo "${{ github.repository }}" | cut -d'/' -f1)
          TOOL_NAME="${{ needs.plan.outputs.NAME }}"
          
          # Ensure TOOL_NAME is not empty - default to 'feza' if missing
          if [ -z "$TOOL_NAME" ]; then
            echo "WARNING: TOOL_NAME is empty, defaulting to 'feza'"
            TOOL_NAME="feza"
          fi
          
          TAP_REPO="${{ secrets.TAP_REPO }}"
          
          # Debug output
          echo "DEBUG: ORG=${ORG}"
          echo "DEBUG: TOOL_NAME=${TOOL_NAME}"
          echo "DEBUG: TAP_REPO secret is: [${TAP_REPO}]"
          echo "DEBUG: TAP_REPO length: ${#TAP_REPO}"
          
          if [ -z "$TAP_REPO" ]; then
            TAP_REPO="${ORG}/homebrew-${TOOL_NAME}"
            echo "Auto-detected tap repo: $TAP_REPO (based on tool name: ${TOOL_NAME})"
          else
            echo "Using configured tap repo: $TAP_REPO"
          fi
          echo "TAP_REPO=${TAP_REPO}" >> $GITHUB_OUTPUT
          
          # Use TAP_PAT if set, otherwise fall back to GITHUB_TOKEN
          TAP_PAT="${{ secrets.TAP_PAT }}"
          if [ -z "$TAP_PAT" ]; then
            TAP_PAT="${{ secrets.GITHUB_TOKEN }}"
            echo "Using GITHUB_TOKEN for tap operations (may not work for cross-repo)"
          else
            echo "Using configured TAP_PAT"
          fi
          echo "TAP_PAT=${TAP_PAT}" >> $GITHUB_OUTPUT

      - name: Checkout tap repository
        uses: actions/checkout@v4
        with:
          repository: ${{ steps.tap.outputs.TAP_REPO }}
          token: ${{ steps.tap.outputs.TAP_PAT }}
          path: tap-repo
          persist-credentials: true

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Feza
        run: |
          python -m pip install --upgrade pip
          pip install -e ./main-repo

      - name: Download manifest
        uses: actions/download-artifact@v4
        with:
          name: manifest-final
          path: main-repo/dist/

      - name: Generate and update formula
        run: |
          cd main-repo
          # Formula class name (capitalized) for template
          FORMULA_CLASS=$(echo "${{ needs.plan.outputs.NAME }}" | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')
          # Formula filename (lowercase) per Homebrew conventions
          FORMULA_FILENAME=$(echo "${{ needs.plan.outputs.NAME }}" | tr '[:upper:]' '[:lower:]' | tr '_' '-')
          
          python -c "
          import sys
          import os
          import subprocess
          from pathlib import Path
          sys.path.insert(0, '.')
          from feza.main import render_formula
          import json
          
          manifest = json.load(open('dist/feza_manifest.json'))
          
          class Args:
              repo = '${{ github.repository }}'
              desc = 'CLI tool'
              homepage = 'https://github.com/${{ github.repository }}'
          
          args = Args()
          formula_content = render_formula(None, manifest, '${FORMULA_CLASS}', args)
          
          # Write to tap repo
          tap_repo = Path('../tap-repo')
          formula_dir = tap_repo / 'Formula'
          formula_dir.mkdir(parents=True, exist_ok=True)
          formula_path = formula_dir / '${FORMULA_FILENAME}.rb'
          
          # Remove any case-variant files to prevent conflicts on case-insensitive filesystems
          for existing_file in formula_dir.glob('*.rb'):
              if existing_file.name.lower() == formula_path.name.lower() and existing_file.name != formula_path.name:
                  # Case-variant file exists - remove it from git and filesystem
                  relative_path = str(existing_file.relative_to(tap_repo))
                  subprocess.run(['git', 'rm', '-f', relative_path], cwd=tap_repo, check=False, capture_output=True)
                  subprocess.run(['git', 'rm', '--cached', '-f', relative_path], cwd=tap_repo, check=False, capture_output=True)
                  if existing_file.exists():
                      existing_file.unlink()
          
          formula_path.write_text(formula_content)
          print(f'Generated formula: Formula/${FORMULA_FILENAME}.rb')
          "

      - name: Install GitHub CLI
        run: |
          if ! command -v gh &> /dev/null; then
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
            sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null
            sudo apt update
            sudo apt install gh -y
          fi

      - name: Create PR for tap update
        run: |
          cd tap-repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Set remote URL with token for push
          git remote set-url origin https://${{ steps.tap.outputs.TAP_PAT }}@github.com/${{ steps.tap.outputs.TAP_REPO }}.git
          
          # Authenticate gh CLI
          echo "${{ steps.tap.outputs.TAP_PAT }}" | gh auth login --with-token
          
          # Create branch for PR (same pattern as feza tap command)
          BRANCH_NAME="feza/${{ needs.plan.outputs.TAG }}"
          
          # Check if PR already exists
          EXISTING_PR=$(gh pr list --repo ${{ steps.tap.outputs.TAP_REPO }} --head $BRANCH_NAME --state all --json number --jq '.[0].number' || echo "")
          if [ -n "$EXISTING_PR" ]; then
            echo "PR #$EXISTING_PR already exists for branch $BRANCH_NAME, skipping creation"
            exit 0
          fi
          
          # Check if branch exists on remote
          if git ls-remote --heads origin $BRANCH_NAME | grep -q .; then
            echo "Branch $BRANCH_NAME already exists on remote, checking out and updating"
            git fetch origin $BRANCH_NAME
            git checkout -b $BRANCH_NAME origin/$BRANCH_NAME || git checkout $BRANCH_NAME
          else
            git checkout -b $BRANCH_NAME
          fi
          
          # Commit formula changes
          git add Formula/*.rb
          if git diff --staged --quiet; then
            echo "No changes to commit, formula already up to date"
          else
            git commit -m "Update ${{ needs.plan.outputs.NAME }} to ${{ needs.plan.outputs.TAG }}"
          fi
          
          # Push branch (force push if it already existed, otherwise normal push)
          if git ls-remote --heads origin $BRANCH_NAME | grep -q .; then
            git push origin $BRANCH_NAME --force-with-lease || git push origin $BRANCH_NAME
          else
            git push origin $BRANCH_NAME
          fi
          
          # Detect default branch dynamically (don't hardcode main)
          DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || git branch -r --format '%(refname:short)' | head -1 | sed 's@origin/@@' || echo "main")
          echo "Detected default branch: $DEFAULT_BRANCH"
          
          # Create PR using gh CLI
          gh pr create \
            --repo ${{ steps.tap.outputs.TAP_REPO }} \
            --base "$DEFAULT_BRANCH" \
            --head $BRANCH_NAME \
            --title "Update ${{ needs.plan.outputs.NAME }} to ${{ needs.plan.outputs.TAG }}" \
            --body "Automated update via Feza workflow for ${{ needs.plan.outputs.TAG }}" \
            || echo "PR may already exist or creation failed"

